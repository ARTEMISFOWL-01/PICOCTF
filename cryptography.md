# PICOCTF

SOLVING PICOCTF

## MOD 26

<p>Description
Crptyptography can be easy, do you know what ROT13 is? cvpbPGS{arkg_gvzr_V'yy_gel_2_ebhaqf_bs_ebg13_jdJBFOXJ}<p>
<p> Rot13 is changing a character with the 13th letter from it. THis can be solve by online rot13 converter but in terminal we can use echo and tr <br>
 echo 'cvpbPGS{arkg_gvzr_V'yy_gel_2_ebhaqf_bs_ebg13_jdJBFOXJ}' | tr 'A-Za-z' 'N-ZA-Mn-za-m'<br>
 FLAG:picoCTF{next_time_I'll_try_2_rounds_of_rot13_wqWOSBKW}<br>

## Mind your Ps and Qs

<p>In RSA, a small e value can be problematic, but what about N? Can you decrypt this? "https://mercury.picoctf.net/static/b9ddda080c56fb421bf30409bec3460d/values"<br>

first lets get the values out of this give link bu using wget to download it<br>
wget https://mercury.picoctf.net/static/b9ddda080c56fb421bf30409bec3460d/values<br>
After downloading use cat to extract value out of "values" file<br>

cat values<br>

<p>Decrypt my super sick RSA:
c: 964354128913912393938480857590969826308054462950561875638492039363373779803642185
n: 1584586296183412107468474423529992275940096154074798537916936609523894209759157543
e: 65537 <br>

now we can use online rsa decoder and public key n,e<br>

FLAG: picoCTF{sma11_N_n0_g0od_73918962}<br>

## Morse code

<p>Description
Morse code is well known. Can you decrypt this?
Download the file here.
Wrap your answer with picoCTF{}, put underscores in place of pauses, and use all lowercase.<br>
lets download the file<br>
wget https://artifacts.picoctf.net/c/79/morse_chal.wav<br>
now by online morse code audio decoder we can get the secret flag<br>
W H 4 7 H 4 7 H 9 0 D W 2 Å  U 9 H 7<br>
changing it into required format<br>
picoCTF{WH47_H47H_90D_W20U9H7}<br>

## flag

 <p>What do the flags mean?<p>
 <p>hint:-The flag is in the format PICOCTF{}<p>

<p>In the given link https://jupiter.challenges.picoctf.org/static/fbeb5f9040d62b18878d199cdda2d253/flag.png we have pictures of some flag i we observe it we can see it is in format of the flag so we can find what different flag here means till the bracket
But I don't have any idea of other flags so I searched "flag symbols and their meaning" on browser and I found some flags and number they represent in see.
In browser I found "flagid.org" i.e a flag identifier if we make the flag we can see what letter they represent so at last I got key as
"PICOCTF{F1AG5AND5TUFF}"<p>

## Transposition-trial

<p>Our data got corrupted on the way here. Luckily, nothing got replaced, but every block of 3 got scrambled around! The first word seems to be three letters long, maybe you can use that to recover the rest of the message.
Download the corrupted message "https://artifacts.picoctf.net/c/192/message.txt"<p>
<p>HINT:-Split the message up into blocks of 3 and see how the first block is scrambled<p>
<p>Hidden message:- heTfl g as iicpCTo      {7F4NRP051N5_16_35P3X51N3_V091B0AE}2<p>
<p>If we observe every set of 3 letters we can see that it's making sense only if 3rd letter of set is change to 1st and 1st to second and 2nd to third like
het - the
fl_ - _fl
g_a - ag_
and so on..<p>
<p>So the code to decrypt the message will be <p>
'''

      s = "heTfl g as iicpCTo{7F4NRP051N5_16_35P3X51N3_V091B0AE}2"

     txt = [s[i:i+3] for i in range(0, len(s), 3)]

     dec = []

     for chunk in txt:

      rearranged = chunk[2] + chunk[0] + chunk[1]

          dec.append(rearranged)

     for element in dec:

        print(element, end='')

'''

# OUTPUT

key= "picoCTF{7R4N5P051N6_15_3XP3N51V3_109AB02E}"

## Substitution1

<p>Description:- It seems that another encrypted message has been intercepted. The encryptor seems to have learned their lesson though and now there isn't any punctuation! Can you still crack the cipher?
Download the message https://artifacts.picoctf.net/c/114/message.txt<p>
<p>HINT:-Try refining your frequency attack, maybe analyzing groups of letters would improve your results?<p>
<p>Message:-"LKOb (bwvek ove lgqkhej kwj osgx) gej g kyqj vo lvrqhkje bjlhetky lvrqjktktvu. Lvukjbkgukb gej qejbjukjz dtkw g bjk vo lwgssjuxjb dwtlw kjbk kwjte lejgktftky, kjlwutlgs (guz xvvxstux) bitssb, guz qevmsjr-bvsftux gmtstky. Lwgssjuxjb hbhgssy lvfje g uhrmje vo lgkjxvetjb, guz dwju bvsfjz, jglw ytjszb g bketux (lgssjz g osgx) dwtlw tb bhmrtkkjz kv gu vustuj blvetux bjeftlj. LKOb gej g xejgk dgy kv sjgeu g dtzj geegy vo lvrqhkje bjlhetky bitssb tu g bgoj, sjxgs juftevurjuk, guz gej wvbkjz guz qsgyjz my rguy bjlhetky xevhqb gevhuz kwj dvesz ove ohu guz qeglktlj. Ove kwtb qevmsjr, kwj osgx tb: qtlvLKO{OE3AH3ULY_4774LI5_4E3_L001_6J0659OM}"<p>

<p>SOLUTION:- From the hint it is clear that it can be solved using frequency attack so, on quipqiup.com we just need to past the message and chose the output that has required format in our case it is picoCTF{}<p>
<p>KEY = "picoCTF{FR3QU3NCY_4774CK5_4R3_C001_6E0659FB}"

## Dachshund Attacks

<p>DESCRIPTION:- What if d is too small? Connect with nc mercury.picoctf.net 58978<p>
<p>HINT:- A picture of Dachshund dog<p>

<p>given in nc mercury.picoctf.net 58978 :- 
e: 12102709540732812992944327037658423375506624694330975987328416449304590892041073972039552005855397807977832223051541783744475039723666151516476945890471106716821786003090954935646985632471538751698950841007365504191824716802754339582713365262382596277657786103988726211471842504516658959590186395216973620337
n: 81497084937029711949971847593603148172032326337340554229397711519822770558769458996742708200746897568370398185862718382762558629295193724375202777846841902540883269912009762851325937421172459079372655894143364484231218644189439143083413982169986874639086957884282882641828652965201544538533814132761212084157
c: 61542505732063943596748994002968623421430413364438423311658878708169099740321043855421664050515641694806812851531031708445436117069684649956174175857434355513078420868692482076347984197952446445353250503945294728325362714240102315791617147985495195792700265195468173803180178635280683127709691575910182361698<p>
 <p>It is clear from here its rsa now from hint we know it is something related to name of dog, now when I searched rsa when d is small it gives "Wiener's attack" that is use in these cases but we don't need to go deep into this as dcode.fr/rsa-cipher can work even if d is small that is it can perform wiener attack
 So, putting values of n,e,d in this we get key as 
 "picoCTF{proving_wiener_6907362}"<p>

## Mini RSA

<p>Description:-What happens if you have a small exponent? There is a twist though, we padded the plaintext so that (M ** e) is just barely larger than N. Let's decrypt this: ciphertext<p>
<p>Now gioven values
'''
     
     N:  1615765684321463054078226051959887884233678317734892901740763321135213636796075462401950274602405095138589898087428337758445013281488966866073355710771864671726991918706558071231266976427184673800225254531695928541272546385146495736420261815693810544589811104967829354461491178200126099661909654163542661541699404839644035177445092988952614918424317082380174383819025585076206641993479326576180793544321194357018916215113009742654408597083724508169216182008449693917227497813165444372201517541788989925461711067825681947947471001390843774746442699739386923285801022685451221261010798837646928092277556198145662924691803032880040492762442561497760689933601781401617086600593482127465655390841361154025890679757514060456103104199255917164678161972735858939464790960448345988941481499050248673128656508055285037090026439683847266536283160142071643015434813473463469733112182328678706702116054036618277506997666534567846763938692335069955755244438415377933440029498378955355877502743215305768814857864433151287
     e: 3

     ciphertext (c): 1220012318588871886132524757898884422174534558055593713309088304910273991073554732659977133980685370899257850121970812405700793710546674062154237544840177616746805668666317481140872605653768484867292138139949076102907399831998827567645230986345455915692863094364797526497302082734955903755050638155202890599808146919581675891411119628108546342758721287307471723093546788074479139848242227243523617899178070097350912870635303707113283010669418774091018728233471491573736725568575532635111164176010070788796616348740261987121152288917179932230769893513971774137615028741237163693178359120276497700812698199245070488892892209716639870702721110338285426338729911942926177029934906215716407021792856449586278849142522957603215285531263079546937443583905937777298337318454706096366106704204777777913076793265584075700215822263709126228246232640662350759018119501368721990988895700497330256765579153834824063344973587990533626156498797388821484630786016515988383280196865544019939739447062641481267899176504155482

'''
As we know (message^e) modulus (n) = ciphertext
and in many cases where e is small like here as 3 wecan directly take cuberoot of ciphertext and if its smaller then n then m^3=c
but if not then m=cuberoot(c+n\*k),wherre k is some integer and m is also integer so we are not sure which case to aply but we can test for k from 0 to thousands of values to see if we get required m, in this case we cna cover both cases, so code will be
'''

     import gmpy2

     n = 1615765684321463054078226051959887884233678317734892901740763321135213636796075462401950274602405095138589898087428337758445013281488966866073355710771864671726991918706558071231266976427184673800225254531695928541272546385146495736420261815693810544589811104967829354461491178200126099661909654163542661541699404839644035177445092988952614918424317082380174383819025585076206641993479326576180793544321194357018916215113009742654408597083724508169216182008449693917227497813165444372201517541788989925461711067825681947947471001390843774746442699739386923285801022685451221261010798837646928092277556198145662924691803032880040492762442561497760689933601781401617086600593482127465655390841361154025890679757514060456103104199255917164678161972735858939464790960448345988941481499050248673128656508055285037090026439683847266536283160142071643015434813473463469733112182328678706702116054036618277506997666534567846763938692335069955755244438415377933440029498378955355877502743215305768814857864433151287
     c = 1220012318588871886132524757898884422174534558055593713309088304910273991073554732659977133980685370899257850121970812405700793710546674062154237544840177616746805668666317481140872605653768484867292138139949076102907399831998827567645230986345455915692863094364797526497302082734955903755050638155202890599808146919581675891411119628108546342758721287307471723093546788074479139848242227243523617899178070097350912870635303707113283010669418774091018728233471491573736725568575532635111164176010070788796616348740261987121152288917179932230769893513971774137615028741237163693178359120276497700812698199245070488892892209716639870702721110338285426338729911942926177029934906215716407021792856449586278849142522957603215285531263079546937443583905937777298337318454706096366106704204777777913076793265584075700215822263709126228246232640662350759018119501368721990988895700497330256765579153834824063344973587990533626156498797388821484630786016515988383280196865544019939739447062641481267899176504155482
     e = 3

     for i in range(4000):
         m, result = gmpy2.iroot(n * i + c, e)
         if result:
             print("m =",m)
             hex_string = format(m, 'x')
             if len(hex_string) % 2 != 0:
                 hex_string = '0' + hex_string
             byte_message = bytes.fromhex(hex_string)
             decoded_message = byte_message.decode()
             print(decoded_message)

             '''

Output:-
'''

     m= 1787330808968142828287809319332701517353332911736848279839502759158602467824780424488141955644417387373185756944952906538004355347478978500948630620749868180414755933760446136287315896825929319145984883756667607031853695069891380871892213007874933611243319812691520078269033745367443951846845107464675742664639073699907476681022428557437

     picoCTF{e_sh0u1d_b3_lArg3r_60ef2420}

     '''

<p>
